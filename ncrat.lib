////////////////////////////////////////////////////////////
version="version ncrat.lib 1.0.0.0 Jan_2018 "; // $Id$
category="Noncommutative";
info="
LIBRARY:      ncrat.lib Framework for working with nc rational functions

AUTHOR:       Ricardo Schnur, email: ricardo.schnur@math.uni-sb.de

OVERVIEW:     This library provides a framework for working with
  non-commutative rational functions and implements an
  algorithm from T. Mai to calculate a linear
  representation of said functions.

REFERENCES:   T. Mai: On the analytic theory of non-commutative
   distributions in free probability. Universitaet des Saarlandes,
   Dissertation, 2017

KEYWORDS:     noncommutative rational functions, representations

PROCEDURES:
  ncInit(list);             Set up framework, list contains nc variables
  ncVarsGet();              List nc variables that are in use
  ncVarsAdd(list);          Add variables from list to 'NCRING'
  ncratDefine();            Define element of type ncrat
  ncratAdd();               Addition of two ncrat's
  ncratSubstract();         Substraction of two ncrat's
  ncratMultiply();          Multiplication of two ncrat's
  ncratInvert();            Invert an ncrat
  ncratTranspose();         Transpose an ncrat
  ncratSPrint();            Print-to-string for ncrat
  ncratPrint();             Print for ncrat
  ncratFromString();        Reads string into ncrat
  ncratFromPoly();          Converts poly to ncrat
  ncratPower(ncrat, int);   Raises ncrat to an integer power
  ncrepGet(ncrat);          Calculate representtion of ncrat
  ncrepAdd();               Addition of two ncrep's
  ncrepSubstract();         Substraction of two ncrep's
  ncrepMultiply();          Multiplication of two ncrep's
  ncrepInvert();            Invert an ncrep
  ncrepPrint();             Print for ncrep
  ncrepSubstitute();        Plug matrices into nc variables in ncrep
  ncrepEvaluate();          Given (u, Q, v) calculate -u*Q^(-1)*v
  ncrepIsInvertible();      Random matrix test for invertibility of ncrep
";

LIB "linalg.lib";
LIB "random.lib";
////////////////////////////////////////////////////////////

/*##########################################################

   STATIC PROCEDURES

##########################################################*/

/*##########################################################

   GENERAL

##########################################################*/

/*##########################################################

   STRING

##########################################################*/

/*---------------------------------------------------------/

  Some tools to work on strings

/---------------------------------------------------------*/

// Is first character a special character?
static proc isSelfRepresented(string s) {
  if (size(s) == 0) {
    ERROR("Called isSelfRepresented() with empty string.");
  }
  if (s[1] == ";" or s[1] == "(" or s[1] == ")" or s[1] == "+" or s[1] == "-" or
      s[1] == "*" or s[1] == "^" or s[1] == "/") {
    return (1);
  }
  return (0);
}

// Is first character a whitespace?
static proc isWhitespace(string s) {
  if (size(s) == 0) {
    ERROR("Called isWhitespace() with empty string.");
  }
  if (s[1] == " " or s[1] == newline) {
    return (1);
  }
  return (0);
}

// Is first character a digit?
static proc isDigit(string s) {
  if (size(s) == 0) {
    ERROR("Called isDigit() with empty string.");
  }
  if (s[1] == "0" or s[1] == "1" or s[1] == "2" or s[1] == "3" or s[1] == "4" or
      s[1] == "5" or s[1] == "6" or s[1] == "7" or s[1] == "8" or s[1] == "9") {
    return (1);
  }
  return (0);
}

// Is first character a letter?
static proc isLetter(string s) {
  if (size(s) == 0) {
    ERROR("Called isLetter() with empty string.");
  }
  if (s[1] == "A" or s[1] == "a" or s[1] == "B" or s[1] == "b" or s[1] == "C" or
      s[1] == "c" or s[1] == "D" or s[1] == "d" or s[1] == "E" or s[1] == "e" or
      s[1] == "F" or s[1] == "f" or s[1] == "G" or s[1] == "g" or s[1] == "H" or
      s[1] == "h" or s[1] == "I" or s[1] == "i" or s[1] == "J" or s[1] == "j" or
      s[1] == "K" or s[1] == "k" or s[1] == "L" or s[1] == "l" or s[1] == "M" or
      s[1] == "m" or s[1] == "N" or s[1] == "n" or s[1] == "O" or s[1] == "o" or
      s[1] == "P" or s[1] == "p" or s[1] == "Q" or s[1] == "q" or s[1] == "R" or
      s[1] == "r" or s[1] == "S" or s[1] == "s" or s[1] == "T" or s[1] == "t" or
      s[1] == "U" or s[1] == "u" or s[1] == "V" or s[1] == "v" or s[1] == "W" or
      s[1] == "w" or s[1] == "X" or s[1] == "x" or s[1] == "Y" or s[1] == "y" or
      s[1] == "Z" or s[1] == "z") {
    return (1);
  }
  return (0);
}

// Convert string representation of a number into number
static proc digitToInt(string s) {
  if (size(s) == 0) {
    ERROR("Called digitToInt() with empty string.");
  }

  if (s[1] == "0") {
    return (0);
  }
  if (s[1] == "1") {
    return (1);
  }
  if (s[1] == "2") {
    return (2);
  }
  if (s[1] == "3") {
    return (3);
  }
  if (s[1] == "4") {
    return (4);
  }
  if (s[1] == "5") {
    return (5);
  }
  if (s[1] == "6") {
    return (6);
  }
  if (s[1] == "7") {
    return (7);
  }
  if (s[1] == "8") {
    return (8);
  }
  if (s[1] == "9") {
    return (9);
  }
  ERROR("digitToInt() not a digit!");
}

// Convert string representation of a number into number
static proc stringToNumber(string s) {
  if (size(s) == 0) {
    ERROR("Called stringToNumber() with empty string.");
  }

  int i;
  number n = 0;
  for (i = 1; i <= size(s); i++) {
    n = n + number(digitToInt(s[i]) * 10 ^ (size(s) - i));
  }

  return (n);
}

/*##########################################################

  END STRING

##########################################################*/

/*##########################################################

   TOKEN

##########################################################*/

/*---------------------------------------------------------/

  Constructors for token and tokenstream

/---------------------------------------------------------*/

// First argument is Kind
// Optional arguments: Value, Name
static proc makeToken(string s, list #) {
  token t;
  int i, n;

  n = size(#);
  t.kind = s;

  for (i = 1; i <= n; i++) {
    if (typeof(#[i]) == "number") {
      t.value = #[i];
    }
    if (typeof(#[i]) == "int") {
      t.value = number(#[i]);
    }
    if (typeof(#[i]) == "string") {
      t.name = #[i];
    }
  }

  return (t);
}

// Constructor for token_stream
static proc makeTokenStream() {
  tokenstream ts;
  ts.full = 0;                    // buffer starts empty
  ts.position = 0;                // initial position
  ts.buffer = makeToken("empty"); // empty buffer
  ts.input = "";                  // no input yet
  return (ts);
}

/*---------------------------------------------------------/

  Member functions for TOKENSTREAM

/---------------------------------------------------------*/

// Put token back into stream
static proc tsPutback(token t) {
  if (TOKENSTREAM.full) {
    ERROR("tsPutback() into full buffer!");
  }
  TOKENSTREAM.buffer = t;
  TOKENSTREAM.full = 1;
}

// Compose next token
static proc tsGet() {
  // Check for token in buffer
  if (TOKENSTREAM.full) {
    TOKENSTREAM.full = 0;
    return (TOKENSTREAM.buffer);
  }

  // Return empty token if there are no others
  if (TOKENSTREAM.position == 0 or
      TOKENSTREAM.position > size(TOKENSTREAM.input)) {
    return (makeToken("empty"));
  }

  // Get token from TOKENSTREAM.input
  int i = TOKENSTREAM.position;
  string s = TOKENSTREAM.input;

  // Skip whitespace
  while (isWhitespace(s[i])) {
    i++;
  }

  if (i > size(s)) {
    ERROR("tsGet() reached end of string!");
  }

  // switch on s[i]
  // characters that represent themselves
  if (isSelfRepresented(s[i])) {
    TOKENSTREAM.position = i + 1;
    return (makeToken(s[i]));
  }

  // numbers
  if (isDigit(s[i])) {
    int start = i;

    while (i < size(s)) {
      if (isDigit(s[i + 1]) == 1) {
        i++;
      } else {
        break;
      }
    }

    int length = i + 1 - start;
    string str = s[start, length];
    TOKENSTREAM.position = i + 1;

    number n = stringToNumber(str);
    return (makeToken("number", n));
  }

  // constants,variables and keywords
  if (isLetter(s[i])) {
    int start = i;

    while (i < size(s)) {
      if (isLetter(s[i + 1]) == 1 or isDigit(s[i + 1]) == 1 or
          s[i + 1] == "_") {
        i++;
      } else {
        break;
      }
    }

    int length = i + 1 - start;
    string name = s[start, length];
    TOKENSTREAM.position = i + 1;

    // keyword
    if (name == "inv") {
      return (makeToken("inv"));
    }
    if (name == "tp") {
      return (makeToken("tp"));
    }

    // constant or variable
    int isVar = 0;
    int isDef = 0;
    string cmd = "if( defined(" + name + ") <> 0 ) {isDef = 1}";
    execute(cmd);
    if (isDef) {
      // constant
      int isConst = 0;
      cmd = "if( typeof(" + name + ") == \"number\" ) {isConst = 1}";
      execute(cmd);
      cmd = "if( typeof(" + name + ") == \"int\" ) {isConst = 1}";
      execute(cmd);
      if (isConst) {
        cmd = "number value = number(" + name + ");";
        execute(cmd);
        return (makeToken("number", value));
      }

      // variable
      for (i = 1; i <= size(NCVARIABLES); i++) {
        if (name == NCVARIABLES[i]) {
          return (makeToken("name", name));
        }
      }

      // neither constant nor variable
      ERROR(name + " already defined, but not a number or a nc variable!");
    }

    ERROR(name + " is undefined and not a nc variable!");
  }

  ERROR("Unrecognized input: " + s[i]);
}

/*##########################################################

  END TOKEN

##########################################################*/

/*##########################################################

   GRAMMAR

##########################################################*/

/*---------------------------------------------------------/

  Input for ncrat function
  according to the following grammar

    Expression:
        Term
        Expression "+" Term
        Expression "-" Term

    Term:
        Secondary
        Term "*" Secondary

    Secondary:
        Primary
        Primary "^" int
        Primary "/" Primary

    Primary:
        Number
        "(" Expression ")"
        "+" Primary
        "-" Primary
        "inv(" Expression ")"
        "tp(" Expression ")"
        Name

    Number:
        digit
        Number digit

    Name:
        letter
        letter Sequence

    Sequence:
        letter
        digit
        "_"
        letter Sequence
        digit Sequence
        "_" Sequence

/---------------------------------------------------------*/

static proc primary() {
  token t = tsGet();

  // switch on t.kind
  // case "(" Expression ")"
  if (t.kind == "(") {
    ncrat f = expression();

    t = tsGet();
    if (t.kind != ")") {
      ERROR("')' expected!");
    }
    return (f);
  }

  // unary +
  if (t.kind == "+") {
    return (primary());
  }

  // unary -
  if (t.kind == "-") {
    ncrat sign = "Const", list(number(-1));
    return (sign * primary());
  }

  // variables and constants
  if (t.kind == "name") {
    ncrat f = "Var", list(t.name);
    return (f);
  }
  // numbers
  if (t.kind == "number") {
    ncrat f = "Const", list(t.value);
    return (f);
  }
  // inversion
  if (t.kind == "inv") {
    t = tsGet();
    if (t.kind != "(") {
      ERROR("'(' expected!");
    }

    ncrat f = expression();

    t = tsGet();
    if (t.kind != ")") {
      ERROR(")' expected!");
    }

    return (ncratInvert(f));
  }
  // involution
  if (t.kind == "tp") {
    t = tsGet();
    if (t.kind != "(") {
      ERROR("'(' expected!");
    }

    ncrat f = expression();

    t = tsGet();
    if (t.kind != ")") {
      ERROR(")' expected!");
    }

    return (ncratTranspose(f));
  }

  ERROR("Primary expected!");
}

static proc secondary() {
  ncrat left = primary();

  while (1) {
    token t = tsGet();
    if (t.kind == "^") {
      ncrat right = primary();

      if (not(right.kind == "Const")) {
        ERROR("Expected integer after '^'.");
      }

      int n = int(right.expr[1]);
      if (not(number(n) == right.expr[1])) {
        ERROR(string(right.expr[1]) + " is not an integer!");
      }

      kill(right);
      kill(t);
      return (ncratPower(left, n));
    }

    if (t.kind == "/") {
      ncrat right = primary();

      if (not(right.kind == "Const")) {
        ERROR("Expected number after '/'.");
      }

      left = left * ncratInvert(right);

      kill(right);
      kill(t);
      return (left);
    }

    tsPutback(t);
    kill(t);
    return (left);
  }
}

static proc term() {
  ncrat left = secondary();

  while (1) {
    token t = tsGet();
    if (t.kind == "*") {
      ncrat right = secondary();
      left = left * right;
      kill(right);
      kill(t);
    } else {
      tsPutback(t);
      kill(t);
      return (left);
    }
  }
}

static proc expression() {
  ncrat left = term();

  while (1) {
    token t = tsGet();
    if (t.kind == "+") {
      ncrat right = term();
      left = left + right;
      kill(right);
      kill(t);
    } else {
      if (t.kind == "-") {
        ncrat right = term();
        left = left - right;
        kill(right);
        kill(t);
      } else {
        tsPutback(t);
        kill(t);
        return (left);
      }
    }
  }
}

/*##########################################################

  END GRAMMAR

##########################################################*/

/*##########################################################

  END GENERAL

##########################################################*/

/*##########################################################

   NCRAT

##########################################################*/

// Define ring 'NCRING' with variables from list
static proc ncRingDefine() {
  // Kill old ring if it already exists
  if (not(defined(NCRING) == 0)) {
    kill(NCRING);
  }

  // Build new ring
  int i;
  string s;

  s = "ring NCRING = (0, I), (";
  for (i = 1; i <= size(NCVARIABLES); i++) {
    if (i == 1) {
      s = s + NCVARIABLES[i];
    } else {
      s = s + ", " + NCVARIABLES[i];
    }
  }
  s = s + "), dp; minpoly = I^2+1;";
  execute(s);
  short = 0;
  exportto(Top, NCRING);
}

static proc ncratIsValid(string s, list l) {

  while (1) {
    if (s == "Const") {
      if (not((size(l) == 1) and (typeof(l[1]) == "number"))) {
        return (0);
      }
      break;
    }

    if (s == "Var") {
      if (not((size(l) == 1) and (typeof(l[1]) == "string"))) {
        return (0);
      }
      break;
    }

    if (s == "Add" or s == "Sub" or s == "Mult") {
      if (not((size(l) == 2) and (typeof(l[1]) == "ncrat") and
              (typeof(l[2]) == "ncrat"))) {
        return (0);
      }
      break;
    }

    if (s == "Inv" or s == "Tp") {
      if (not((size(l) == 1) and (typeof(l[1]) == "ncrat"))) {
        return (0);
      }
      break;
    }

    break;
  }

  return (1);
}

/*##########################################################

  END NCRAT

##########################################################*/

/*##########################################################

   NCREP

##########################################################*/

// Handle constants
static proc ncrepConst(number n) {
  ncrep q;
  matrix left[1][2] = 0, 1;
  matrix right[2][1] = 0, 1;
  matrix Q[2][2] = n, -1, -1, 0;
  q.lvec = left;
  q.rvec = right;
  q.mat = Q;
  return (q);
}

// Handle variables
static proc ncrepVar(poly p) {
  ncrep q;
  matrix left[1][2] = 0, 1;
  matrix right[2][1] = 0, 1;
  matrix Q[2][2] = p, -1, -1, 0;
  q.lvec = left;
  q.rvec = right;
  q.mat = Q;
  return (q);
}

// Tensor A with unit matrix of size N
static proc ncTensorMat(matrix A, int N) {
  matrix E[N][N];
  E = E + 1;
  matrix M = tensor(A, E);
  return (M);
}

// Substitute all occurences of VARIABLE*E in M with A
static proc ncSubMat(matrix M, matrix A, poly VARIABLE) {
  int N = ncols(A);
  int N2 = ncols(M);
  int N3 = N2 div N;
  if (not(N * N3 == N2)) {
    ERROR("Size of arg1 must be a multiple of size of arg2!");
  }

  int n, m, i, j;
  poly p;
  for (i = 1; i <= N3; i++) {
    for (j = 1; j <= N3; j++) {
      p = M[1 + (i - 1) * N, 1 + (j - 1) * N] / VARIABLE;
      if (not(p == 0)) {
        M[1 + (i - 1) * N..i * N, 1 + (j - 1) * N..j * N] = p * A;
      }
    }
  }
  return (M);
}

/*##########################################################

  END NCREP

##########################################################*/

/*##########################################################

  END STATIC PROCEDURES

##########################################################*/

/*##########################################################

   NON-STATIC PROCEDURES

##########################################################*/

/*##########################################################

   GENERAL

##########################################################*/

proc ncInit(list vars) "
USAGE:
  ncInit(vars);        list vars containing strings

RETURNS:
  datatypes ncrat and ncrep (and token, tokenstream,
  but they are not meant for users),
  sets ring as 'NCRING' with nc variables from list l

EXAMPLE:
  example ncInit;      shows an example
"
{
  // Check if already initialized
  if (defined(NCRATINITIALIZE)) {
    return ();
  }
  int NCRATINITIALIZE = 1;
  export(NCRATINITIALIZE);

  // Check if variables are specified
  if (size(vars) == 0) {
    ERROR("No nc variables specified!");
  }

  /*---------------------------------------------------------/

      Datatype 'ncrat' for nc rational functions

      The following constructions are allowed:
        ("Const", [number])           constant
        ("Var",   [string])           variable
        ("Add",   [ncrat, ncrat])     addition
        ("Sub",   [ncrat, ncrat])     substraction
        ("Mult",  [ncrat, ncrat])     multiplication
        ("Inv",   [ncrat])            inverse
        ("Tp",    [ncrat])            involution (transpose)

  /---------------------------------------------------------*/

  newstruct("ncrat", "
    string kind,
    list expr
  ");


  /*---------------------------------------------------------/

      Struct for representations

  /---------------------------------------------------------*/

  newstruct("ncrep", "
    matrix lvec,
    matrix mat,
    matrix rvec
  ");


  /*---------------------------------------------------------/

      Structs for handling input

  /---------------------------------------------------------*/

  newstruct("token", "
    string kind,
    number value,
    string name
  ");


  newstruct("tokenstream", "
    int full,
    int position,
    token buffer,
    string input
  ");


  /*---------------------------------------------------------/

      Overloading operators for ncrat

  /---------------------------------------------------------*/

  system("install", "ncrat", "=", ncratDefine, 1);
  system("install", "ncrat", "+", ncratAdd, 2);
  system("install", "ncrat", "-", ncratSubstract, 2);
  system("install", "ncrat", "*", ncratMultiply, 2);
  system("install", "ncrat", "^", ncratPower, 2);
  system("install", "ncrat", "print", ncratPrint, 1);
  system("install", "ncrep", "print", ncrepPrint, 1);


  /*---------------------------------------------------------/

      Global objects

  /---------------------------------------------------------*/

  list NCVARIABLES = vars;
  export(NCVARIABLES);

  tokenstream TOKENSTREAM = makeTokenStream();
  export(TOKENSTREAM);

  ncRingDefine();
}
example {
  "EXAMPLE:";
  "ncInit(list(\" x \", \" y \", \" z \"));";
  ncInit(list("x", "y", "z"));
  "NCRING;";
  NCRING;
}

proc ncVarsGet() "
USAGE:
  ncVarsGet();

RETURNS:
  nc variables that are in use

EXAMPLE:
  example ncVarsGet;   shows an example
"
{
  string(NCVARIABLES);
}
example {
  "EXAMPLE:";
  "ncInit(list(\" x \", \" y \", \" z \"));";
  ncInit(list("x", "y", "z"));
  "ncVarsGet();";
  ncVarsGet();
}

// Add variables to 'NCRING'
proc ncVarsAdd(list vars) {
  int i, j;
  int exists = 0;

  for (i = 1; i <= size(vars); i++) {
    for (j = 1; j <= size(NCVARIABLES); j++) {
      if (vars[i] == NCVARIABLES[j]) {
        exists = 1;
      }
    }
    if (exists == 0) {
      NCVARIABLES = NCVARIABLES + list(vars[i]);
    } else {
      exists = 0;
    }
  }

  ncRingDefine();
}

/*##########################################################

  END GENERAL

##########################################################*/

/*##########################################################

   NCRAT

##########################################################*/

// Definition of elements of type 'ncrat'
proc ncratDefine(string s, list l) {
  if (not(ncratIsValid(s, l))) {
    ERROR("Not a valid rational expression!");
  }

  ncrat f;
  f.kind = s;
  f.expr = l;
  return (f);
}

// Addition
proc ncratAdd(ncrat f, ncrat g) {
  ncrat h = "Add", list(f, g);
  return (h);
}

// Substraction
proc ncratSubstract(ncrat f, ncrat g) {
  ncrat h = "Sub", list(f, g);
  return (h);
}

// Multiplication
proc ncratMultiply(ncrat f, ncrat g) {
  // Both factors are constants
  if (f.kind == "Const" and g.kind == "Const") {
    ncrat h = "Const", list(f.expr[1] * g.expr[1]);
    return (h)
  }

  // Only second factor is a constant
  // Switch order of multiplication
  if (g.kind == "Const") {
    return (ncratMultiply(g, f));
  }

  // Otherwise
  ncrat h = "Mult", list(f, g);
  return (h);
}

// Inversion
proc ncratInvert(ncrat f) {
  ncrat h;
  if (f.kind == "Const") {
    number n = 1;
    number m = f.expr[1];
    h = "Const", list(n / m);
  } else {
    h = "Inv", list(f);
  }
  return (h);
}

// Involution
proc ncratTranspose(ncrat f) {
  ncrat h = "Tp", list(f);
  return (h);
}

// Print rational function to string
proc ncratSPrint(ncrat f) {
  string t, h, k;
  string s = f.kind;
  list l = f.expr;

  if (s == "Const") {
    t = string(l[1]);
  }

  if (s == "Var") {
    t = l[1];
  }

  if (s == "Add") {
    t = ncratSPrint(l[1]) + "+" + ncratSPrint(l[2]);
  }

  if (s == "Sub") {
    if (l[2].kind == "Add" or l[2].kind == "Sub") {
      h = "(" + ncratSPrint(l[2]) + ")";
    } else {
      h = ncratSPrint(l[2]);
    }
    t = ncratSPrint(l[1]) + "-" + h;
  }

  if (s == "Mult") {
    if (l[1].kind == "Add" or l[1].kind == "Sub") {
      h = "(" + ncratSPrint(l[1]) + ")";
    } else {
      h = ncratSPrint(l[1]);
    }
    if (l[2].kind == "Add" or l[2].kind == "Sub") {
      k = "(" + ncratSPrint(l[2]) + ")";
    } else {
      k = ncratSPrint(l[2]);
    }
    t = h + "*" + k;
  }

  if (s == "Inv") {
    t = "inv(" + ncratSPrint(l[1]) + ")";
  }

  if (s == "Tp") {
    t = "tp(" + ncratSPrint(l[1]) + ")";
  }

  return (t);
}

// Print rational function to console
proc ncratPrint(ncrat f) { print(ncratSPrint(f)); }

// Read string into ncrat
proc ncratFromString(string s) {
  // Clear tokenstream
  TOKENSTREAM.input = s;
  TOKENSTREAM.position = 1;
  TOKENSTREAM.full = 0;

  ncrat f = expression();
  return (f);
}

// Convert poly to ncrat
proc ncratFromPoly(poly p) {
  string s = print(p);
  ncrat f = ncratFromString(s);
  return (f);
}

// Integer powers of rational functions
proc ncratPower(ncrat f, int n) {
  if (n < 0) {
    return (ncratInvert(ncratPower(f, -n)));
  }

  if (n == 0) {
    return (ncratFromString("1"));
  }

  if (n == 1) {
    return (f);
  }

  return (ncratPower(f, n - 1) * f);
}

/*##########################################################

  END NCRAT

##########################################################*/

/*##########################################################

   NCREP

##########################################################*/

// Get representation of rational function
proc ncrepGet(ncrat f) {
  ncrep q;

  // switch on f.kind
  if (f.kind == "Const") {
    q = ncrepConst(f.expr[1]);
    return (q);
  }

  if (f.kind == "Var") {
    string s = "poly p = " + f.expr[1] + ";";
    execute(s);
    q = ncrepVar(p);
    return (q);
  }

  if (f.kind == "Add") {
    q = ncrepAdd(ncrepGet(f.expr[1]), ncrepGet(f.expr[2]));
    return (q);
  }

  if (f.kind == "Sub") {
    q = ncrepSubstract(ncrepGet(f.expr[1]), ncrepGet(f.expr[2]));
    return (q);
  }

  if (f.kind == "Mult") {
    // First factor is a constant
    if (f.expr[1].kind == "Const") {
      q = ncrepGet(f.expr[2]);
      q.mat = q.mat / f.expr[1].expr[1];
      return (q);
    }

    // Second factor is a constant
    if (f.expr[2].kind == "Const") {
      q = ncrepGet(f.expr[1]);
      q.mat = q.mat / f.expr[2].expr[1];
      return (q);
    }

    // No constant factors
    q = ncrepMultiply(ncrepGet(f.expr[1]), ncrepGet(f.expr[2]));
    return (q);
  }

  if (f.kind == "Inv") {
    q = ncrepInvert(ncrepGet(f.expr[1]));
    return (q);
  }

  if (f.kind == "Tp") {
    q = ncrepTp(ncrepGet(f.expr[1]));
    return (q);
  }
}

// Handle sums
proc ncrepAdd(ncrep s, ncrep t) {
  ncrep q;
  q.lvec = concat(s.lvec, t.lvec);
  q.rvec = transpose(concat(transpose(s.rvec), transpose(t.rvec)));
  q.mat = dsum(s.mat, t.mat);
  return (q);
}

// Handle differences
proc ncrepSubstract(ncrep s, ncrep t) {
  ncrep q;
  q.lvec = concat(s.lvec, t.lvec);
  q.rvec = transpose(concat(transpose(s.rvec), transpose(t.rvec)));
  q.mat = dsum(s.mat, -t.mat);
  return (q);
}

// Handle products
proc ncrepMultiply(ncrep s, ncrep t) {
  ncrep q;
  int dims = ncols(s.lvec);
  int dimt = ncols(t.lvec);
  matrix lzero[1][dimt] = 0;
  matrix rzero[dims][1] = 0;
  matrix mzero[dimt][dims] = 0;

  q.lvec = concat(lzero, s.lvec);
  q.rvec = transpose(concat(transpose(rzero), transpose(t.rvec)));

  matrix A = concat(s.rvec * t.lvec, s.mat);
  matrix B = concat(t.mat, mzero);
  q.mat = transpose(concat(transpose(A), transpose(B)));

  return (q);
}

// Handle inverses
proc ncrepInvert(ncrep s) {
  ncrep q;
  int n = ncols(s.lvec);
  matrix one[1][1] = 1;
  matrix vzero[1][n] = 0;
  matrix mzero[1][1] = 0;

  q.lvec = concat(one, vzero);
  q.rvec = transpose(q.lvec);

  matrix A = concat(mzero, s.lvec);
  matrix B = concat(s.rvec, -s.mat);
  q.mat = transpose(concat(transpose(A), transpose(B)));

  return (q);
}

// Print representation to console
proc ncrepPrint(ncrep q) {
  print("lvec=");
  print(q.lvec);
  print(newline + "mat=");
  print(q.mat);
  print(newline + "rvec=");
  print(q.rvec);
}

// Replace variable xi by matrix Ai in q.mat
// list(A1, x1, A2, x2, ...), A_i matrix, x_i poly
proc ncrepSubstitute(ncrep q, list #) {
  int length = size(#);

  // List empty
  if (length == 0) {
    return (q.mat);
  }

  // List odd length
  if (length % 2 == 1) {
    ERROR("List has odd length!");
  }

  // List non-empty
  def A = #[1];
  def p = #[2];
  if (not(typeof(A) == "matrix" or typeof(A) == "number" or
          typeof(A) == "int") or
      not(typeof(p) == "poly")) {
    ERROR("Invalid argument!")
  }

  int N = ncols(A);
  matrix M = ncTensorMat(q.mat, N);
  M = ncSubMat(M, A, p);

  int i;
  for (i = 1; i < length; i = i + 2) {
    A = #[i];
    p = #[i + 1];
    if (not(typeof(A) == "matrix" or typeof(A) == "number" or
            typeof(A) == "int") or
        not(typeof(p) == "poly")) {
      ERROR("Invalid argument!")
    }
    M = ncSubMat(M, A, p);
  }

  ncrep q2;
  q2.mat = M;
  q2.lvec = ncTensorMat(q.lvec, N);
  q2.rvec = ncTensorMat(q.rvec, N);

  return (q2);
}

// For representation (u, Q, v) calculate -u*Q^(-1)*v
proc ncrepEvaluate(ncrep q) {
  matrix M = -q.lvec * inverse(q.mat) * q.rvec;
  return (M);
}

/*---------------------------------------------------------/

  Test whether q.mat is invertible via evaluation
  at random matrix points with integer coefficients
  in [-maxcoeff, maxcoeff]. Stops after n tries.
  Use ixi-matrix in i-th try. The list contains the
  variables which occur in q.

/---------------------------------------------------------*/
proc ncrepIsInvertible(ncrep q, list vars, int n, int maxcoeff) {
  int N = size(vars);
  int i, k;
  for (i = 1; i <= n; i++) {
    // Substitute random matrices
    list l;
    for (k = 1; k <= N; k++) {
      matrix A(k) = randommat(i, i, maxideal(0), maxcoeff);
      l = l + list(A(k), vars[k]);
      kill(A(k));
    }
    ncrep q2 = ncrepSubstitute(q, l);
    kill(l);

    // Check for invertibility
    if (mat_rk(q2.mat) == ncols(q2.mat)) {
      kill(q2);
      return (i)
    }
    kill(q2);
  }
  return (0);
}

/*##########################################################

  END NCREP

##########################################################*/

/*##########################################################

  END NON-STATIC PROCEDURES

##########################################################*/
